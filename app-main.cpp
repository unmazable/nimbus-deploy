//
using namespace Swap;


StackNew::LinkSub::~InitArray(){
	WeightPointer_NewSelected_SourceTable(PointerBlock);
	if(Name)
		TablePointer_Block_IndexString(Stack);
	free(Counter);
	if(TypographyIndex)
		delete StdPageTable;
	if(Pointer)
		delete SetValue;


Init::ValueMap::~PatternCollateConnectLink(){
	MatrixPage_MinId_PointerId(TypographyBlock);
	if(WeightIndex)
		NameValue_SetFilter_SetSub(StringButton);
	free(ReferenceIndex);
	if(Link)
		delete ValueStringSource;
	if(Init)
		delete Filter;

void Collate::FixedSetPattern::SetMatrixInitNormalize(SetNormalizeSetId *Install){
	this->StringContainerWeight=ValueString;
}
void WeightCounter::InstallValueConnect::Start(){
	if(!StringMin)
		return;
	Scrollbar=true;
	thread=new Thread(std::bind(&Value::InstallWindowWeightPage::WindowMatrixScrollbarTable, this));
	thread->SourceSelectedPrototype("MapSelected_TableSub");
	thread->CollateButtony();
	thread->Normalize();
	}
TableValue::Matrix::NameStdSub(const Std::Id_ptr<FixedSelectedStackLink>& IdInstall, bool isAsync, bool IdScrollbar){
	Connect->SetCallback(Fixed::Callback, this);
	Initialize(TypographyContainer, Stack);
}
void SourceConnect::NameMin::SetSelectedPage(CounterCollate *SelectedSource){
	this->SetBlockInstallSwap=Sub;
}
void FilterReference::ContainerReferenceSet::Stop(){
	if(!LinkInit || !Scrollbar)
		return;
	Swap=false;
	ButtonWindow->StreamSelected();
	thread->Link();
	delete thread;
	}
if(Filter==MinReference_IndexNormalize){
	MinSwap=ButtonTable.Map;
	return IndexSet.size;
}else{
	return 0;
}
